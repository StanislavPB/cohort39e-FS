# Lesson 01

###  Многопоточность. Введение
### Общие сведения**

1. **Введение**
   - XX век ознаменовался появлением компьютеров в современном понимании.
   - Развитие технологий стимулировало уменьшение размеров ЭВМ и повышение их производительности и энергоэффективности.
   - Появление микросборок и микросхем.
   - Формулировка «закона» Мура, предсказывающего удвоение числа транзисторов на микросхемах каждые два года.

2. **Основные элементы в компьютере**
   - Процессор как ключевой элемент, исполняющий инструкции программ.
   - Развитие процессоров от одноядерных к многоядерным для увеличения производительности.

3. **Краткое описание работы процессора**
   - Арифметико-логическое устройство (АЛУ) как центральная часть процессора.
   - Регистры, шины данных и адреса, декодер инструкций.
   - Основные операции АЛУ и принципы их выполнения.

4. **Поддержка на уровне операционной системы**
   - ОС распределяет время процессора между процессами различными методами: простая смена задач, кооперативная и вытесняющая многозадачность.
   - Отличие кооперативной от вытесняющей многозадачности по методике распределения времени процессора.

5. **Концепции вычислений**
   - Последовательные вычисления, выполняющие задачи последовательно.
   - Параллельные вычисления, позволяющие обрабатывать множество задач одновременно на многоядерных процессорах.

6. **Процессы и потоки**
   - Определение и различие между процессом и потоком.
   - Процессы как независимые единицы с собственными ресурсами.
   - Потоки как подзадачи внутри процесса, использующие общие ресурсы.
   - Разница между потоками и процессами в контексте информации, использования памяти и скорости переключения.

7. **Многопоточность и алгоритм разделения времени**
   - Time-slicing как метод распределения времени процессора между потоками.
   - Отличие имитации параллельности в одноядерных системах от реальной параллельности в многоядерных.

8. **Преимущества и недостатки многопоточности**
   - Улучшение адаптивности и производительности приложений с помощью многопоточности.
   - Вызовы в дизайне и отладке многопоточных приложений.
   - Проблемы с синхронизацией данных и переключением контекстов между потоками.

9. **Закон Амдала**
   - Иллюстрация ограничений на увеличение производительности системы за счёт параллелизма.
   - Влияние непараллелизуемой части кода на общую производительность.

10. **Современные технологии многопоточности**
- Графические процессоры (GPU) и их роль в параллельных вычислениях.
- Применение многопоточности в облачных вычислениях и микросервисах.
- Использование многопоточности в больших данных и искусственном интеллекте.

#### Средства для работы с многопоточностью в Java

**Java 1.0**: В самой первой версии Java были представлены базовые средства для работы с потоками:
   - Класс `Thread` для представления потоков выполнения.
   - Интерфейс `Runnable` для определения кода, который может выполняться в потоке.
   - Методы `wait()`, `notify()`, и `notifyAll()` в классе `Object` для взаимодействия между потоками.

**Java 1.2**: Введены улучшения в библиотеку коллекций, что косвенно повлияло на многопоточное программирование, например, введение потокобезопасных коллекций, таких как `Hashtable` и `Vector`.

**Java 1.5 (Java 5)**: Версия Java 5 стала значительным шагом в развитии многопоточности:
   - Пакет `java.util.concurrent` представил множество новых конструкций для многопоточного программирования, включая `ExecutorService`, `CyclicBarrier`, `Semaphore`, `ConcurrentHashMap` и другие.
   - Введены новые возможности для управления блокировками через классы `Lock` и `ReentrantLock`.
   - Добавлены атомарные классы в пакете `java.util.concurrent.atomic`, предоставляющие операции без блокировок на одиночных переменных.

**Java 1.8 (Java 8)**: Введение `CompletableFuture`, который предлагает новый способ работы с асинхронным программированием и комбинированием асинхронных операций. Появление лямбда-выражений также упростило использование некоторых аспектов многопоточности.

#### Модели многопоточных программ
- Синхронизация, блокировки, `volatile`.
- Транзакционная память, рекурсивный параллелизм.
- Модель акторов: взаимодействие объектов-акторов через обмен сообщениями.

#### Проблемы, решаемые многопоточностью (продолжение)

1. **Одновременное выполнение нескольких действий**: Многопоточность улучшает интерактивность и отзывчивость приложений.
2. **Ускорение вычислений**: Эффективное распределение задач по ядрам процессора сокращает время выполнения.

#### Проблемы, создаваемые многопоточностью

1. **Взаимная блокировка (Deadlock)**: Ситуация, когда потоки в ожидании ресурсов, занятых другими потоками, не могут продолжить работу.
2. **Состояние гонки (Race Condition)**: Ошибка, приводящая к зависимости системы от последовательности выполнения потоков.

#### Что должен знать Java-разработчик о многопоточности

**Уровень Junior**:
- Основы многопоточности в Java.
- Синтаксис для работы с потоками.
- Основы `java.util.concurrent`.

**Уровень Middle**:
- Глубокое понимание инструментов Java для многопоточности.
- Многопоточность в контексте Spring.
- Разработка многопоточных функций.

**Уровень Senior**:
- Продвинутые знания инструментов и библиотек для многопоточности.
- Применение многопоточности в различных сценариях.
- Архитектурная интеграция многопоточности в приложения.

###  **Создание и запуск потоков в Java**
   В Java потоки можно создавать двумя способами: наследуясь от класса `Thread` или реализуя интерфейс `Runnable`.

   - **Пример с наследованием от класса Thread:**

     ```java
     class MyThread extends Thread {
         public void run() {
             System.out.println("Поток запущен: " + Thread.currentThread().getName());
         }
     }

     public class Main {
         public static void main(String[] args) {
             MyThread thread = new MyThread();
             thread.start();
         }
     }
     ```

   - **Пример с реализацией интерфейса Runnable:**

     ```java
     class MyRunnable implements Runnable {
         public void run() {
             System.out.println("Поток запущен: " + Thread.currentThread().getName());
         }
     }

     public class Main {
         public static void main(String[] args) {
             Thread thread = new Thread(new MyRunnable());
             thread.start();
         }
     }
     ```
