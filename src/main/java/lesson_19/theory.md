# Lesson 19


Freemarker — это шаблонизатор на Java, который помогает разработчикам генерировать HTML-страницы, конфигурационные файлы и другие текстовые форматы, используя шаблоны. Этот инструмент широко применяется для создания веб-страниц в Java-приложениях. Вот подробное описание работы с Freemarker для создания страниц в Java-приложении:

### Основы Freemarker

Freemarker не обрабатывает HTML сам по себе; он создаёт HTML-файлы на основе шаблонов, которые вы определяете. Шаблоны Freemarker написаны в собственном декларативном языке и содержат статический текст (который будет частью конечного документа) и директивы Freemarker, которые управляют созданием динамического контента.

### Компоненты Freemarker

1. **Шаблоны**: Шаблоны Freemarker (обычно с расширением `.ftl`) — это текстовые файлы, содержащие фиксированный текст и специальные конструкции для динамической вставки данных.

2. **Модель данных**: Данные, которые должны быть вставлены в шаблон, обычно представлены в виде карты (Map) или другой структуры данных в Java, которая передаётся в шаблонизатор при обработке.

3. **Конфигурация**: Объект Configuration в Freemarker управляет всеми аспектами поведения шаблонизатора, включая спецификации форматирования, локализацию и другие настройки.

### Пример работы с Freemarker

#### 1. Настройка

Перед использованием Freemarker в вашем проекте добавьте зависимость в ваш `pom.xml` или `build.gradle` файл:

```xml
<!-- Для Maven -->
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.31</version> <!-- Проверьте последнюю версию -->
</dependency>
```

```groovy
// Для Gradle
implementation 'org.freemarker:freemarker:2.3.31' // Проверьте последнюю версию
```

#### 2. Создание конфигурации

```java
import freemarker.template.Configuration;
import freemarker.template.Version;

Configuration cfg = new Configuration(new Version("2.3.31"));
cfg.setDirectoryForTemplateLoading(new File("/path/to/templates"));
cfg.setDefaultEncoding("UTF-8");
cfg.setLocale(Locale.US);
cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
```

#### 3. Подготовка модели данных

```java
Map<String, Object> root = new HashMap<>();
root.put("user", "John Doe");
List<String> messages = Arrays.asList("Your application is up and running.", "Enjoy Freemarker!");
root.put("messages", messages);
```

#### 4. Обработка шаблона

```java
/* Загрузите шаблон */
Template temp = cfg.getTemplate("test.ftl");

/* Соедините модель данных с шаблоном и выводите результаты */
try (Writer out = new OutputStreamWriter(System.out)) {
    temp.process(root, out);
}
```

#### 5. Шаблон test.ftl

```plaintext
<html>
<head>
  <title>Welcome</title>
</head>
<body>
  <h1>Welcome ${user}!</h1>
  <p>Messages:</p>
  <ul>
  <#list messages as message>
    <li>${message}</li>
  <#list>
  </ul>
</body>
</html>
```

Этот пример демонстрирует базовый процесс создания HTML-страницы с использованием динамических данных.
Freemarker мощный и гибкий, поддерживающий сложные операции с данными и форматированием текста.


### Аспектно-ориентированное программирование (АОП) 
Представляет собой парадигму, направленную на увеличение модульности приложений путем разделения сквозных задач.
Этот подход позволяет добавлять дополнительное поведение к существующему коду без необходимости его модификации.

или по другому:


Aspect-Oriented Programming (AOP) в Java представляет собой парадигму программирования, которая дополняет традиционное объектно-ориентированное программирование (ООП) путём добавления "аспектов".
Это позволяет инкапсулировать функциональность, которая не является основной для бизнес-логики, но необходима для поддержки системы, такую как логирование, безопасность, транзакционность и кэширование.


В основе АОП лежит идея о том, что можно "навешивать" дополнительную функциональность на методы и классы, не внося изменения в исходный код.
Это особенно важно, когда традиционные объектно-ориентированные методы не справляются с определенными задачами.
АОП предоставляет новые инструменты, увеличивая гибкость разработки и расширяя возможности для решения разнообразных задач.

### Применение АОП

Аспектно-ориентированное программирование применяется для решения сквозных задач, которые трудно выделить в отдельные модули. С помощью АОП такие задачи можно эффективно изолировать от основного кода. Например, это может быть политика безопасности, которая должна применяться консистентно ко всем частям приложения, как к существующим, так и к новым. В этом контексте политики безопасности могут развиваться и адаптироваться вместе с приложением.

Примеры использования АОП включают, но не ограничиваются, логирование и обработку исключений. Преимущества АОП в случае логирования:
- Легкость внедрения и удаления кода логирования через конфигурационные изменения.
- Централизация кода логирования в одном месте, упрощающая управление и обновление.
- Возможность добавления логирования к существующим и новым элементам приложения, что снижает вероятность ошибок.
- Уверенность в полном удалении трассировочного кода при удалении аспекта из конфигурации.

АОП также используется для кеширования и переиспользования функционала, что позволяет улучшить производительность и масштабируемость приложений.

### Основные понятия АОП

- **Совет (Advice)**: код, выполняемый в определенные моменты выполнения программы, например, до, после или вместо вызова метода.
- **Точка соединения (Join point)**: место в программе, где может быть применен совет.
- **Срез (Pointcut)**: набор точек соединения, определяющий, когда и где применяется совет.
- **Аспект (Aspect)**: модуль, реализующий сквозную функциональность, связывая советы с точками соединения.
- **Внедрение (Introduction)**: процесс, позволяющий добавлять новые методы или поля в существующие классы.
- **Плетение (Weaving)**: процесс, при котором аспекты интегрируются с другими компонентами программы, который может происходить на этапе компиляции, после компиляции или во время загрузки класса.


1. **Аспект (Aspect)**: Модуль, инкапсулирующий поведение (advice) и точки присоединения (pointcuts) в одном месте вне определения класса, на который это поведение влияет.

2. **Advice**: Код, который выполняется в определенных точках программы. Существует несколько типов advice:
    - **Before**: Выполняется до вызова метода.
    - **After**: Выполняется после вызова метода.
    - **After-returning**: Выполняется после успешного завершения метода.
    - **After-throwing**: Выполняется, если метод вызывает исключение.
    - **Around**: Заменяет метод, обеспечивая возможность выполнения дополнительного кода до и после вызова метода.

3. **Pointcut**: Выражение, определяющее моменты в программе, когда должны применяться advices. Pointcuts определяют "где" и "когда" в программе будет выполняться advice.

4. **Join Point**: Конкретная точка в программе, такая как вызов метода или обращение к переменной.

5. **Target Object**: Объект, к которому применяется аспект.

6. **Weaving**: Процесс, в котором аспекты интегрируются в целевую программу.


AspectJ является одной из популярных реализаций АОП, предоставляющей разнообразные инструменты для работы со сквозными задачами.
Эта технология позволяет разработчикам более эффективно управлять и модифицировать поведение приложений, улучшая их архитектурную чистоту и гибкость.


### Примеры:

1. **Логирование**:
    - **Aspect**:
      ```java
      @Aspect
      public class LoggingAspect {
          @Before("execution(* com.example.service.*.*(..))")
          public void logBefore(JoinPoint joinPoint) {
              System.out.println("Before method: " + joinPoint.getSignature().getName());
          }
      }
      ```

2. **Безопасность**:
    - **Aspect**:
      ```java
      @Aspect
      public class SecurityAspect {
          @Before("execution(* com.example.service.*.*(..))")
          public void checkAuthentication() {
              // проверка аутентификации пользователя
          }
      }
      ```

3. **Транзакционность**:
    - **Aspect**:
      ```java
      @Aspect
      public class TransactionAspect {
          @Around("execution(* com.example.service.*.*(..))")
          public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
              try {
                  // начало транзакции
                  Object result = joinPoint.proceed();
                  // завершение транзакции
                  return result;
              } catch (Exception e) {
                  // откат транзакции
                  throw e;
              }
          }
      }
      ```

В этих примерах аспекты используют аннотации Spring AOP для определения advices и pointcuts. AOP позволяет разработчикам более чётко разделять основную логику приложения от перекрестных проблем (cross-cutting concerns), таких как логирование или безопасность, что упрощает поддержку и развитие программного обеспечения.





 

